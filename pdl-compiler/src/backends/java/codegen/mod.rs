// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use genco::{
    self,
    prelude::{java, Java},
    quote, quote_fn, quote_in,
    tokens::FormatInto,
    Tokens,
};
use heck::{self, ToUpperCamelCase};
use std::iter::{self};

mod packet;

use super::{
    import, Chunk, Class, ClassDef, EndiannessValue, GeneratorContext, Integral, PacketDef, Type,
    Variable,
};

impl FormatInto<Java> for Class<'_> {
    fn format_into(self, tokens: &mut Tokens<Java>) {
        quote_in!(*tokens =>
            $(java::block_comment(iter::once(
                format!("GENERATED BY PDL COMPILER FROM {}", self.ctx.pdl_src))
            ))
            $(match &self.def {
                ClassDef::Packet { children, def } if children.is_empty() => $(def.gen_packet(&self.name, self.ctx)),
                ClassDef::Packet { children, def } => $(def.gen_parent_packet(&self.name, children, self.ctx)),
                ClassDef::Subpacket { parent, def: Some(def) } => $(def.gen_child_packet(&self.name, parent, self.ctx)),
                ClassDef::Subpacket { parent, def: None } => $(self.gen_payload_packet(&self.name, parent)),
            })
        );
    }
}

impl GeneratorContext {
    fn gen_byte_order(&self) -> impl FormatInto<Java> + '_ {
        quote_fn! {
            private static final $(&*import::BO) BYTE_ORDER = $(match self.endianness {
                EndiannessValue::LittleEndian => $(&*import::BO).LITTLE_ENDIAN,
                EndiannessValue::BigEndian => $(&*import::BO).BIG_ENDIAN,
            });
        }
    }
}

trait Expr {
    fn maybe_cast(self, from: Integral, to: Integral) -> Tokens<Java>;
    fn maybe_widen(self, from: &Type, to: Integral) -> Tokens<Java>;
    fn maybe_shift(self, op: &'static str, by: usize) -> Tokens<Java>;
    fn maybe_mask(self, offset: usize, width: usize) -> Tokens<Java>;
}

impl<J: FormatInto<Java>> Expr for J {
    /// `from` and `to` must be >= int
    fn maybe_cast(self, from: Integral, to: Integral) -> Tokens<Java> {
        quote! {
            $(match (from, to) {
                (Integral::Int, Integral::Long) => Integer.toUnsignedLong($(self)),
                (Integral::Long, Integral::Int) => ((int) ($(self))),
                _ => $(self),
            })
        }
    }

    /// `from` and `to` must be >= int
    fn maybe_widen(self, from: &Type, to: Integral) -> Tokens<Java> {
        quote! {
            $(match (from, to) {
                (Type::Integral(Integral::Int), Integral::Long) => Integer.toUnsignedLong($(self)),
                _ => $(self),
            })
        }
    }

    fn maybe_mask(self, offset: usize, width: usize) -> Tokens<Java> {
        quote! {
            $(if width == 0 {
                $(self.maybe_shift(">>>", offset))
            } else {
                ($(self.maybe_shift(">>>", offset)) & $(gen_mask(width)))
            } )
        }
    }

    fn maybe_shift(self, op: &'static str, by: usize) -> Tokens<Java> {
        quote! {
            $(if by == 0 {
                $(self)
            } else {
                ($(self) $op $by)
            })
        }
    }
}

impl Variable {
    fn setter<'a>(&'a self, expr: impl FormatInto<Java> + 'a) -> impl FormatInto<Java> + 'a {
        quote_fn! {
            set$(self.name.to_upper_camel_case())($expr)
        }
    }

    fn stringify(&self) -> impl FormatInto<Java> + '_ {
        quote_fn! {
            $(match &self.ty {
                Type::Integral(i) => $(i.boxed()).toHexString($(&self.name)),
                Type::Class(_) => $(&self.name).toString(),
            })
        }
    }

    fn hash_code(&self) -> impl FormatInto<Java> + '_ {
        quote_fn! {
            $(match &self.ty {
                Type::Integral(i) => $(i.boxed()).hashCode($(&self.name)),
                Type::Class(_) => $(&self.name).hashCode(),
            })
        }
    }

    fn equals<'a>(&'a self, other: impl FormatInto<Java> + 'a) -> impl FormatInto<Java> + 'a {
        quote_fn! {
            $(match &self.ty {
                Type::Integral(_) => $(&self.name) == $other,
                Type::Class(_) => $(&self.name).equals($other),
            })
        }
    }
}

impl FormatInto<Java> for &Type {
    fn format_into(self, tokens: &mut Tokens<Java>) {
        quote_in!(*tokens => $(match self {
            Type::Integral(i) => $(*i),
            Type::Class(import) => $import,
        }));
    }
}

impl Type {
    fn boxed(&self) -> impl FormatInto<Java> + '_ {
        match self {
            Type::Integral(i) => i.boxed(),
            Type::Class(c) => c,
        }
    }
}

impl Integral {
    fn encoder(&self) -> impl FormatInto<Java> + '_ {
        match self {
            Integral::Byte => "put",
            Integral::Short => "putShort",
            Integral::Int => "putInt",
            Integral::Long => "putLong",
        }
    }

    fn decoder<'a>(&'a self, buf: impl FormatInto<Java> + 'a) -> impl FormatInto<Java> + 'a {
        quote_fn! {
            $(match self {
                Integral::Byte => Byte.toUnsignedInt($buf.get()),
                Integral::Short => Short.toUnsignedInt($buf.getShort()),
                Integral::Int => $buf.getInt(),
                Integral::Long => $buf.getLong(),
            })
        }
    }

    fn boxed(&self) -> &'static str {
        match self {
            Integral::Byte => "Byte",
            Integral::Short => "Short",
            Integral::Int => "Integer",
            Integral::Long => "Long",
        }
    }
}

impl FormatInto<Java> for Integral {
    fn format_into(self, tokens: &mut java::Tokens) {
        quote_in!(*tokens => $(match self {
            Integral::Byte => byte,
            Integral::Short => short,
            Integral::Int => int,
            Integral::Long => long,
        }));
    }
}

pub fn gen_mask(width: usize) -> impl FormatInto<Java> {
    quote_fn! {
        $(format!("0x{:x}", (1_u128 << width) - 1))$(if Integral::fitting_width(width) > Integral::Int => L)
    }
}
