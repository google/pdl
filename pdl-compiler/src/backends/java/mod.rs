// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use genco::{
    self,
    prelude::{java, quote, Java},
};
use heck::{self, ToLowerCamelCase, ToUpperCamelCase};
use std::{cmp, iter};

use crate::{
    ast::{self, EndiannessValue},
    backends::common::alignment::{ByteAligner, Chunk},
};

pub mod import {
    use genco::prelude::java;
    use once_cell::sync::Lazy;

    pub static BO: Lazy<java::Import> = Lazy::new(|| java::import("java.nio", "ByteOrder"));
    pub static BB: Lazy<java::Import> = Lazy::new(|| java::import("java.nio", "ByteBuffer"));
}

mod codegen;

pub fn generate(
    sources: &ast::SourceDatabase,
    file: &ast::File,
    custom_fields: &[String],
) -> String {
    let source = sources.get(file.file).expect("could not read source");
    let java_files = generate_java_files(&file);
    java_files.iter().map(|f| f.generate(source.name())).collect::<Vec<String>>().join("\n")
}

fn generate_java_files(file: &ast::File) -> Vec<JavaFile> {
    let mut files = Vec::new();

    for decl in file.declarations.iter() {
        match &decl.desc {
            ast::DeclDesc::Packet { id, constraints, fields, parent_id } => {
                files.push(JavaFile {
                    package: "com.example".to_string(),
                    class: Class::Packet(PacketDef::new(
                        id.to_upper_camel_case(),
                        file.endianness.value,
                        fields,
                    )),
                });
            }
            _ => todo!(),
        }
    }

    files
}

pub struct JavaFile {
    pub package: String,
    pub class: Class,
}

impl JavaFile {
    pub fn generate(&self, pdl_file_name: &str) -> String {
        let mut w = genco::fmt::FmtWriter::new(String::new());
        let fmt = genco::fmt::Config::from_lang::<Java>().with_newline("\n");
        let config = java::Config::default().with_package(&self.package);
        let format = java::Format::default();

        let tokens: java::Tokens = quote! {
            $(java::block_comment(iter::once(format!("GENERATED BY PDL COMPILER FROM {}", pdl_file_name))))
            $['\n']
            $(&self.class)
        };

        tokens.format(&mut w.as_formatter(&fmt), &config, &format).unwrap();
        w.into_inner()
    }
}

pub enum Class {
    Packet(PacketDef),
    Enum { name: String },
}

pub struct PacketDef {
    name: String,
    endianness: EndiannessValue,
    members: Vec<Variable>,
    chunks: Vec<Chunk<Variable>>,
}

impl PacketDef {
    pub fn new(name: String, endianness: EndiannessValue, fields: &Vec<ast::Field>) -> Self {
        let mut members = vec![];
        let mut aligner = ByteAligner::<Variable>::new(64);

        for field in fields {
            match &field.desc {
                ast::FieldDesc::Scalar { id, width } => {
                    let variable = Variable {
                        ty: Type::from_width(*width).limit_to_int(),
                        name: id.to_lower_camel_case(),
                        width: *width,
                    };

                    aligner.add_field(variable.clone(), *width);
                    members.push(variable);
                }
                _ => todo!(),
            }
        }

        PacketDef {
            name: name.to_upper_camel_case(),
            endianness,
            members,
            chunks: aligner.into_aligned_chunks().expect("Failed to align fields"),
        }
    }

    pub fn get_byte_width(&self) -> usize {
        self.members.iter().map(|member| member.width).sum::<usize>() / 8
    }
}

/// The JLS specifies that operands of certain operators including
///  - [shifts](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.19)
///  - [bitwise operators](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.22.1)
///
/// are subject to [widening primitive conversion](https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2). Effectively,
/// this means that `byte` or `short` operands are casted to `int` before the operation. Furthermore, Java does not have unsigned types,
/// so:
///
/// > A widening conversion of a signed integer value to an integral type T simply sign-extends the two's-complement representation of the integer value to fill the wider format.
///
/// In other words, bitwise operations on smaller types can change the binary representation of the value before the operation.
/// To get around this, we only use types `int` and `long` for variables, even when the field would fit in something smaller. This way,
/// we can forget that 'widening primitive conversion' is a thing and pretend that all is right with the world.
#[derive(Debug, Clone)]
pub struct Variable {
    name: String,
    ty: Type,
    width: usize,
}

impl From<&ast::Field> for Variable {
    fn from(field: &ast::Field) -> Self {
        match &field.desc {
            ast::FieldDesc::FixedScalar { width, value } => {
                println!("width: {}, value: {}", width, value);
                todo!()
            }
            ast::FieldDesc::Scalar { id, width } => Variable {
                name: id.to_lower_camel_case(),
                ty: Type::from_width(*width),
                width: *width,
            },
            _ => todo!(),
        }
    }
}

#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
pub enum Type {
    Byte,
    Short,
    Int,
    Long,
}

impl Type {
    pub fn from_width(width: usize) -> Self {
        if width <= 8 {
            Type::Byte
        } else if width <= 16 {
            Type::Short
        } else if width <= 32 {
            Type::Int
        } else if width <= 64 {
            Type::Long
        } else {
            panic!("Width too large!")
        }
    }

    pub fn limit_to_int(self) -> Self {
        cmp::max(self, Type::Int)
    }

    pub fn get_width(&self) -> u8 {
        match self {
            Type::Byte => 8,
            Type::Short => 16,
            Type::Int => 32,
            Type::Long => 64,
        }
    }
}
