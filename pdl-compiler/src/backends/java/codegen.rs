// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use genco::{
    self,
    prelude::{java, Java},
    quote_fn, quote_in,
    tokens::{quoted, FormatInto},
    Tokens,
};
use heck::{self, ToUpperCamelCase};
use std::iter;

use super::{import, Class, ClassDef, PacketDef, Type, Variable};
use crate::{ast::EndiannessValue, backends::common::alignment::Chunk};

impl FormatInto<Java> for Class<'_> {
    fn format_into(self, tokens: &mut Tokens<Java>) {
        quote_in!(*tokens =>
            $(java::block_comment(iter::once(
                format!("GENERATED BY PDL COMPILER FROM {}", self.ctx.pdl_src))
            ))
            $(self.def.generate(&self.name, self.ctx.endianness))
        );
    }
}

impl ClassDef {
    fn generate<'a>(
        &'a self,
        name: &'a str,
        endianness: EndiannessValue,
    ) -> impl FormatInto<Java> + 'a {
        quote_fn! {
            $(match self {
                ClassDef::Packet(def) => $(def.generate(name, endianness)),
                _ => todo!()
            })
        }
    }
}

impl PacketDef {
    fn generate<'a>(
        &'a self,
        name: &'a str,
        endianness: EndiannessValue,
    ) -> impl FormatInto<Java> + 'a {
        quote_fn! {
            public class $name {
                public static final int WIDTH = $(self.get_byte_width());
                private static final $(&*import::BO) BYTE_ORDER = $(match endianness {
                    EndiannessValue::LittleEndian => $(&*import::BO).LITTLE_ENDIAN,
                    EndiannessValue::BigEndian => $(&*import::BO).BIG_ENDIAN,
                });

                $(for member in self.members.iter() => private final $(member.ty) $(&member.name);)

                private $name() {
                    throw new UnsupportedOperationException();
                }

                private $name(Builder builder) {
                    $(for member in self.members.iter() => $(&member.name) = builder.$(&member.name);)
                }

                public static $name fromBytes(byte[] bytes) {
                    $(DecoderDef(&self.chunks))
                }

                public byte[] toBytes() {
                    $(EncoderDef(&self.chunks))
                }

                $(for member in self.members.iter() {
                    $(member.getter_def())
                })

                @Override
                public String toString() {
                    return $(quoted(format!("{}{{\n", name)))
                    $(for member in self.members.iter() {
                        $[' ']
                            + $(quoted(format!("{}[{}]=", &member.name, &member.width)))
                            + $(member.stringify())
                            + "\n"
                    })
                    + "}";
                }

                @Override
                public boolean equals(Object o) {
                    if (this == o) return true;
                    if (!(o instanceof $name other)) return false;
                    return $(for member in self.members.iter() join (&& ) => $(&member.name) == other.$(&member.name));
                }

                @Override
                public int hashCode() {
                    $(let mut members = self.members.iter())
                    $(let first = members.next().expect("cannot generate hashCode for packet with no members"))
                    int result = $(first.ty.as_boxed_str()).hashCode($(&first.name));
                    $(for member in members => result = 31 * result + $(member.ty.as_boxed_str()).hashCode($(&member.name));)
                    return result;
                }

                public static class Builder {
                    $(for member in self.members.iter() => private $(member.ty) $(&member.name);)

                    public Builder() { }

                    public $name build() {
                        return new $name(this);
                    }

                    $(for member in self.members.iter() {
                        $(member.setter_def())
                    })
                }
            }
        }
    }
}

struct EncoderDef<'a>(&'a Vec<Chunk<Variable>>);

impl FormatInto<Java> for EncoderDef<'_> {
    fn format_into(self, tokens: &mut Tokens<Java>) {
        quote_in!(*tokens => $(&*import::BB) buf = $(&*import::BB).allocate(WIDTH).order(BYTE_ORDER););

        for chunk in self.0 {
            let chunk_type = Type::from_width(chunk.width);
            let mut fields = chunk.fields.iter();

            quote_in!(*tokens =>
                $(let first = fields.next()
                    .expect("Attempt to generate encoder for chunk with no fields"))

                buf.$(chunk_type.encoder())(
                    ($chunk_type) (
                        $(first.symbol.name.as_str()
                            .maybe_widen(first.symbol.ty, chunk_type)
                            .maybe_shift(">>>", first.symbol_offset))

                        $(for field in fields => |
                            $(field.symbol.name.as_str()
                                .maybe_widen(field.symbol.ty, chunk_type)
                                .maybe_shift("<<", field.chunk_offset))))););
        }

        quote_in!(*tokens => return buf.array(););
    }
}

struct DecoderDef<'a>(&'a Vec<Chunk<Variable>>);

impl FormatInto<Java> for DecoderDef<'_> {
    fn format_into(self, tokens: &mut Tokens<Java>) {
        quote_in!(*tokens =>
            $(&*import::BB) buf = $(&*import::BB).wrap(bytes).order(BYTE_ORDER);
            Builder b = new Builder();
        );

        for (i, chunk) in self.0.iter().enumerate() {
            let chunk_name = format!("chunk{}", i);
            let chunk_type = Type::from_width(chunk.width).limit_to_int();

            quote_in!(*tokens => $chunk_type $(&chunk_name) = $(Type::from_width(chunk.width).decoder("buf")););

            for field in chunk.fields.iter() {
                quote_in!(*tokens =>
                    $(let decoded_field =
                        chunk_name.as_str()
                            .maybe_mask(field.chunk_offset, field.width)
                            .maybe_cast(chunk_type, field.symbol.ty))

                    $(if field.width == field.symbol.width {
                        // The whole value lies within this chunk, so just set it.
                        b.$(field.symbol.setter())($decoded_field);
                    } else {
                        // The value is split between chunks.
                        $(if field.symbol_offset == 0 {
                            // This chunk has the lower-order bits of the value, so store them in a variable until we can
                            // get the higher-order bits from the next chunk.
                            $(field.symbol.ty) $(&field.symbol.name)$i = $decoded_field;
                        } else {
                            // This chunk has the higher-order bits of the value, so grab the lower-order bits from the
                            // variable we declared.
                            b.$(field.symbol.setter())(
                                    $(&field.symbol.name)$(i - 1) | (($decoded_field) << $(field.symbol_offset)));
                        })
                    })

                )
            }
        }

        quote_in!(*tokens => return b.build(););
    }
}

trait Expr {
    fn maybe_cast(self, from: Type, to: Type) -> impl FormatInto<Java>;
    fn maybe_widen(self, from: Type, to: Type) -> impl FormatInto<Java>;
    fn maybe_shift(self, op: &'static str, by: usize) -> impl FormatInto<Java>;
    fn maybe_mask(self, offset: usize, width: usize) -> impl FormatInto<Java>;
}

impl<J: FormatInto<Java>> Expr for J {
    /// `from` and `to` must be >= int
    fn maybe_cast(self, from: Type, to: Type) -> impl FormatInto<Java> {
        quote_fn! {
            $(match (from, to) {
                (Type::Int, Type::Long) => Integer.toUnsignedLong($(self)),
                (Type::Long, Type::Int) => ((int) ($(self))),
                _ => $(self),
            })
        }
    }

    /// `from` and `to` must be >= int
    fn maybe_widen(self, from: Type, to: Type) -> impl FormatInto<Java> {
        quote_fn! {
            $(if from == Type::Int && to == Type::Long {
                Integer.toUnsignedLong($(self))
            } else {
                $(self)
            })
        }
    }

    fn maybe_mask(self, offset: usize, width: usize) -> impl FormatInto<Java> {
        quote_fn! {
            $(if width == 0 {
                $(self.maybe_shift(">>>", offset))
            } else {
                ($(self.maybe_shift(">>>", offset)) & $(gen_mask(width)))
            } )
        }
    }

    fn maybe_shift(self, op: &'static str, by: usize) -> impl FormatInto<Java> {
        quote_fn! {
            $(if by == 0 {
                $(self)
            } else {
                ($(self) $op $by)
            })
        }
    }
}

impl Variable {
    fn getter_def(&self) -> impl FormatInto<Java> + '_ {
        quote_fn! {
            public $(self.ty) get$(&self.name.to_upper_camel_case())() {
                return $(&self.name);
            }
        }
    }

    fn setter_def(&self) -> impl FormatInto<Java> + '_ {
        quote_fn! {
            public Builder set$(&self.name.to_upper_camel_case())($(self.ty) $(&self.name)) {
                if ($(self.ty.as_boxed_str()).compareUnsigned($(&self.name), $(gen_mask(self.width))) > 0) {
                    throw new IllegalArgumentException(
                        "Value " + $(self.stringify())
                        + $(quoted(format!(" too wide for field '{}' with width {}", &self.name, self.width)))
                    );
                }
                this.$(&self.name) = $(&self.name);
                return this;
            }
        }
    }

    fn setter(&self) -> impl FormatInto<Java> + '_ {
        quote_fn!(
            set$(&self.name.to_upper_camel_case())
        )
    }

    fn stringify(&self) -> impl FormatInto<Java> + '_ {
        quote_fn! {
            $(self.ty.as_boxed_str()).toHexString($(&self.name))
        }
    }
}

impl Type {
    fn encoder(&self) -> &'static str {
        match self {
            Type::Byte => "put",
            Type::Short => "putShort",
            Type::Int => "putInt",
            Type::Long => "putLong",
        }
    }

    fn decoder<'a>(&'a self, buf: impl FormatInto<Java> + 'a) -> impl FormatInto<Java> + 'a {
        quote_fn! {
            $(match self {
                Type::Byte => Byte.toUnsignedInt($buf.get()),
                Type::Short => Short.toUnsignedInt($buf.getShort()),
                Type::Int => $buf.getInt(),
                Type::Long => $buf.getLong(),
            })
        }
    }

    fn as_boxed_str(&self) -> &'static str {
        match self {
            Type::Byte => "Byte",
            Type::Short => "Short",
            Type::Int => "Integer",
            Type::Long => "Long",
        }
    }
}

impl FormatInto<Java> for Type {
    fn format_into(self, tokens: &mut java::Tokens) {
        quote_in!(*tokens => $(match self {
            Type::Byte => byte,
            Type::Short => short,
            Type::Int => int,
            Type::Long => long,
        }));
    }
}

fn gen_mask(width: usize) -> impl FormatInto<Java> {
    quote_fn! {
        $(format!("0x{:x}", (1_u128 << width) - 1))$(if Type::from_width(width) > Type::Int => L)
    }
}
