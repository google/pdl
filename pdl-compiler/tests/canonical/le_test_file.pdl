little_endian_packets

// Preliminary definitions

custom_field SizedCustomField : 8 "SizedCustomField"
custom_field UnsizedCustomField "UnsizedCustomField"
checksum Checksum : 8 "Checksum"

enum Enum7 : 7 {
    A = 1,
    B = 2,
}

enum Enum16 : 16 {
    A = 0xaabb,
    B = 0xccdd,
}

struct SizedStruct {
    a: 8,
}

struct UnsizedStruct {
    _size_(array): 2,
    _reserved_: 6,
    array: 8[],
}

group ScalarGroup {
    a: 16
}

group EnumGroup {
    a: Enum16
}

packet ScalarParent {
    a: 8,
    _size_(_payload_): 8,
    _payload_
}

packet EnumParent {
    a: Enum16,
    _size_(_payload_): 8,
    _payload_
}

packet EmptyParent : ScalarParent {
    _payload_
}

// Start: little_endian_only
packet PartialParent5 {
    a: 5,
    _payload_
}

packet PartialParent12 {
    a: 12,
    _payload_
}
// End: little_endian_only

// Packet bit fields

// The parser must be able to handle bit fields with scalar values
// up to 64 bits wide.  The parser should generate a static size guard.
packet Packet_Scalar_Field {
    a: 7,
    c: 57,
}

// The parser must be able to handle bit fields with enum values
// up to 64 bits wide.  The parser should generate a static size guard.
packet Packet_Enum_Field {
    a: Enum7,
    c: 57,
}

// The parser must be able to handle bit fields with reserved fields
// up to 64 bits wide.  The parser should generate a static size guard.
packet Packet_Reserved_Field {
    a: 7,
    _reserved_: 2,
    c: 55,
}

// The parser must be able to handle bit fields with size fields
// up to 64 bits wide.  The parser should generate a static size guard.
packet Packet_Size_Field {
    _size_(b): 3,
    a: 61,
    b: 8[],
}

// The parser must be able to handle bit fields with count fields
// up to 64 bits wide.  The parser should generate a static size guard.
packet Packet_Count_Field {
    _count_(b): 3,
    a: 61,
    b: 8[],
}

// The parser must be able to handle bit fields with fixed scalar values
// up to 64 bits wide.  The parser should generate a static size guard.
packet Packet_FixedScalar_Field {
    _fixed_ = 7 : 7,
    b: 57,
}

// The parser must be able to handle bit fields with fixed enum values
// up to 64 bits wide. The parser should generate a static size guard.
packet Packet_FixedEnum_Field {
    _fixed_ = A : Enum7,
    b: 57,
}

// Packet payload fields

// The parser must be able to handle sized payload fields without
// size modifier.
packet Packet_Payload_Field_VariableSize {
    _size_(_payload_): 3,
    _reserved_: 5,
    _payload_
}

// The parser must be able to handle sized payload fields with
// size modifier.
packet Packet_Payload_Field_SizeModifier {
    _size_(_payload_): 3,
    _reserved_: 5,
    _payload_ : [+2],
}

// The parser must be able to handle payload fields of unkonwn size followed
// by fields of statically known size. The remaining span is integrated
// in the packet.
packet Packet_Payload_Field_UnknownSize {
    _payload_,
    a: 16,
}

// The parser must be able to handle payload fields of unkonwn size.
// The remaining span is integrated in the packet.
packet Packet_Payload_Field_UnknownSize_Terminal {
    a: 16,
    _payload_,
}

// Packet body fields

// The parser must be able to handle sized body fields without
// size modifier when the packet has no children.
packet Packet_Body_Field_VariableSize {
    _size_(_body_): 3,
    _reserved_: 5,
    _body_
}

// The parser must be able to handle body fields of unkonwn size followed
// by fields of statically known size. The remaining span is integrated
// in the packet.
packet Packet_Body_Field_UnknownSize {
    _body_,
    a: 16,
}

// The parser must be able to handle body fields of unkonwn size.
// The remaining span is integrated in the packet.
packet Packet_Body_Field_UnknownSize_Terminal {
    a: 16,
    _body_,
}

// Packet group fields

packet Packet_ScalarGroup_Field {
    ScalarGroup { a = 42 },
}

packet Packet_EnumGroup_Field {
    EnumGroup { a = A },
}

// Packet checksum fields

// The parser must be able to handle checksum fields if the checksum value
// field is positioned at constant offset from the checksum start.
// The parser should generate a checksum guard for the buffer covered by the
// checksum.
packet Packet_Checksum_Field_FromStart {
    _checksum_start_(crc),
    a: 16,
    b: 16,
    crc: Checksum,
}

// The parser must be able to handle checksum fields if the checksum value
// field is positioned at constant offset from the end of the packet.
// The parser should generate a checksum guard for the buffer covered by the
// checksum.
packet Packet_Checksum_Field_FromEnd {
    _checksum_start_(crc),
    _payload_,
    crc: Checksum,
    a: 16,
    b: 16,
}

// Packet typedef fields

// The parser must be able to handle struct fields.
// The size guard is generated by the Struct parser.
packet Packet_Struct_Field {
    a: SizedStruct,
    b: UnsizedStruct,
}

// The parser must be able to handle custom fields of constant size.
// The parser should generate a static size guard.
packet Packet_Custom_Field_ConstantSize {
    a: SizedCustomField,
}

// The parser must be able to handle custom fields of undefined size.
// No size guard possible.
packet Packet_Custom_Field_VariableSize {
    a: UnsizedCustomField,
}

// Array field configurations.
// Add constructs for all configurations of type, size, and padding:
//
// - type: u8, u16, enum, struct with static size, struct with dynamic size
// - size: constant, with size field, with count field, unspecified
//
// The type u8 is tested separately since it is likely to be handled
// idiomatically by the specific language generators.

packet Packet_Array_Field_ByteElement_ConstantSize {
    array: 8[4],
}

packet Packet_Array_Field_ByteElement_VariableSize {
    _size_(array) : 4,
    _reserved_: 4,
    array: 8[],
}

packet Packet_Array_Field_ByteElement_VariableCount {
    _count_(array) : 4,
    _reserved_: 4,
    array: 8[],
}

packet Packet_Array_Field_ByteElement_UnknownSize {
    array: 8[],
}

packet Packet_Array_Field_ScalarElement_ConstantSize {
    array: 16[4],
}

packet Packet_Array_Field_ScalarElement_VariableSize {
    _size_(array) : 4,
    _reserved_: 4,
    array: 16[],
}

packet Packet_Array_Field_ScalarElement_VariableCount {
    _count_(array) : 4,
    _reserved_: 4,
    array: 16[],
}

packet Packet_Array_Field_ScalarElement_UnknownSize {
    array: 16[],
}

packet Packet_Array_Field_EnumElement_ConstantSize {
    array: Enum16[4],
}

packet Packet_Array_Field_EnumElement_VariableSize {
    _size_(array) : 4,
    _reserved_: 4,
    array: Enum16[],
}

packet Packet_Array_Field_EnumElement_VariableCount {
    _count_(array) : 4,
    _reserved_: 4,
    array: Enum16[],
}

packet Packet_Array_Field_EnumElement_UnknownSize {
    array: Enum16[],
}

packet Packet_Array_Field_SizedElement_ConstantSize {
    array: SizedStruct[4],
}

packet Packet_Array_Field_SizedElement_VariableSize {
    _size_(array) : 4,
    _reserved_: 4,
    array: SizedStruct[],
}

packet Packet_Array_Field_SizedElement_VariableCount {
    _count_(array) : 4,
    _reserved_: 4,
    array: SizedStruct[],
}

packet Packet_Array_Field_SizedElement_UnknownSize {
    array: SizedStruct[],
}

packet Packet_Array_Field_UnsizedElement_ConstantSize {
    array: UnsizedStruct[4],
}

packet Packet_Array_Field_UnsizedElement_VariableSize {
    _size_(array) : 4,
    _reserved_: 4,
    array: UnsizedStruct[],
}

packet Packet_Array_Field_UnsizedElement_VariableCount {
    _count_(array) : 4,
    _reserved_: 4,
    array: UnsizedStruct[],
}

packet Packet_Array_Field_UnsizedElement_UnknownSize {
    array: UnsizedStruct[],
}

// The parser must support complex size modifiers on arrays whose size is
// specified by a size field.
packet Packet_Array_Field_UnsizedElement_SizeModifier {
    _size_(array) : 4,
    _reserved_: 4,
    array: UnsizedStruct[+2],
}

// The parser must be able to handle arrays with padded size.
packet Packet_Array_Field_SizedElement_VariableSize_Padded {
    _size_(array) : 4,
    _reserved_: 4,
    array: 16[],
    _padding_ [16],
}

// The parser must be able to handle arrays with padded size.
packet Packet_Array_Field_UnsizedElement_VariableCount_Padded {
    _count_(array) : 8,
    array: UnsizedStruct[],
    _padding_ [16],
}

// Packet inheritance

// The parser must handle specialization into
// any child packet of a parent packet with scalar constraints.
packet ScalarChild_A : ScalarParent (a = 0) {
    b: 8,
}

// The parser must handle specialization into
// any child packet of a parent packet with scalar constraints.
packet ScalarChild_B : ScalarParent (a = 1) {
    c: 16,
}

// The parser must handle specialization into
// any child packet of a parent packet with enum constraints.
packet EnumChild_A : EnumParent (a = A) {
    b: 8,
}

// The parser must handle specialization into
// any child packet of a parent packet with enum constraints.
packet EnumChild_B : EnumParent (a = B) {
    c: 16,
}

// The parser must handle aliasing of packets
// through inheritance with no constraints
packet AliasedChild_A : EmptyParent (a = 2) {
    b: 8,
}

// The parser must handle aliasing of packets
// through inheritance with no constraints
packet AliasedChild_B : EmptyParent (a = 3) {
    c: 16,
}

// Start: little_endian_only

// The parser must handle inheritance of packets with payloads starting
// on a shifted byte boundary, as long as the first fields of the child
// complete the bit fields.
packet PartialChild5_A : PartialParent5 (a = 0) {
    b: 11,
}

// The parser must handle inheritance of packets with payloads starting
// on a shifted byte boundary, as long as the first fields of the child
// complete the bit fields.
packet PartialChild5_B : PartialParent5 (a = 1) {
    c: 27,
}

// The parser must handle inheritance of packets with payloads starting
// on a shifted byte boundary, as long as the first fields of the child
// complete the bit fields.
packet PartialChild12_A : PartialParent12 (a = 2) {
    d: 4,
}

// The parser must handle inheritance of packets with payloads starting
// on a shifted byte boundary, as long as the first fields of the child
// complete the bit fields.
packet PartialChild12_B : PartialParent12 (a = 3) {
    e: 20,
}

// End: little_endian_only

// Struct bit fields

// The parser must be able to handle bit fields with scalar values
// up to 64 bits wide.  The parser should generate a static size guard.
struct Struct_Scalar_Field {
    a: 7,
    c: 57,
}

// The parser must be able to handle bit fields with enum values
// up to 64 bits wide.  The parser should generate a static size guard.
struct Struct_Enum_Field_ {
    a: Enum7,
    c: 57,
}
packet Struct_Enum_Field {
    s: Struct_Enum_Field_,
}

// The parser must be able to handle bit fields with reserved fields
// up to 64 bits wide.  The parser should generate a static size guard.
struct Struct_Reserved_Field_ {
    a: 7,
    _reserved_: 2,
    c: 55,
}
packet Struct_Reserved_Field {
    s: Struct_Reserved_Field_,
}

// The parser must be able to handle bit fields with size fields
// up to 64 bits wide.  The parser should generate a static size guard.
struct Struct_Size_Field_ {
    _size_(b): 3,
    a: 61,
    b: 8[],
}
packet Struct_Size_Field {
    s: Struct_Size_Field_,
}

// The parser must be able to handle bit fields with count fields
// up to 64 bits wide.  The parser should generate a static size guard.
struct Struct_Count_Field_ {
    _count_(b): 3,
    a: 61,
    b: 8[],
}
packet Struct_Count_Field {
    s: Struct_Count_Field_,
}

// The parser must be able to handle bit fields with fixed scalar values
// up to 64 bits wide.  The parser should generate a static size guard.
struct Struct_FixedScalar_Field_ {
    _fixed_ = 7 : 7,
    b: 57,
}
packet Struct_FixedScalar_Field {
    s: Struct_FixedScalar_Field_,
}

// The parser must be able to handle bit fields with fixed enum values
// up to 64 bits wide. The parser should generate a static size guard.
struct Struct_FixedEnum_Field_ {
    _fixed_ = A : Enum7,
    b: 57,
}
packet Struct_FixedEnum_Field {
    s: Struct_FixedEnum_Field_,
}

// Struct group fields

struct Struct_ScalarGroup_Field_ {
    ScalarGroup { a = 42 },
}
packet Struct_ScalarGroup_Field {
    s: Struct_ScalarGroup_Field_,
}

struct Struct_EnumGroup_Field_ {
    EnumGroup { a = A },
}
packet Struct_EnumGroup_Field {
    s: Struct_EnumGroup_Field_,
}

// Struct checksum fields

// The parser must be able to handle checksum fields if the checksum value
// field is positioned at constant offset from the checksum start.
// The parser should generate a checksum guard for the buffer covered by the
// checksum.
struct Struct_Checksum_Field_FromStart_ {
    _checksum_start_(crc),
    a: 16,
    b: 16,
    crc: Checksum,
}
packet Struct_Checksum_Field_FromStart {
    s: Struct_Checksum_Field_FromStart_,
}

// The parser must be able to handle checksum fields if the checksum value
// field is positioned at constant offset from the end of the packet.
// The parser should generate a checksum guard for the buffer covered by the
// checksum.
struct Struct_Checksum_Field_FromEnd_ {
    _checksum_start_(crc),
    _payload_,
    crc: Checksum,
    a: 16,
    b: 16,
}
packet Struct_Checksum_Field_FromEnd {
    s: Struct_Checksum_Field_FromEnd_,
}

// Struct typedef fields

// The parser must be able to handle struct fields.
// The size guard is generated by the Struct parser.
packet Struct_Struct_Field {
    a: SizedStruct,
    b: UnsizedStruct,
}

// The parser must be able to handle custom fields of constant size.
// The parser should generate a static size guard.
struct Struct_Custom_Field_ConstantSize_ {
    a: SizedCustomField,
}
packet Struct_Custom_Field_ConstantSize {
    s: Struct_Custom_Field_ConstantSize_,
}

// The parser must be able to handle custom fields of undefined size.
// No size guard possible.
struct Struct_Custom_Field_VariableSize_ {
    a: UnsizedCustomField,
}
packet Struct_Custom_Field_VariableSize {
    s: Struct_Custom_Field_VariableSize_,
}

// Array field configurations.
// Add constructs for all configurations of type, size, and padding:
//
// - type: u8, u16, enum, struct with static size, struct with dynamic size
// - size: constant, with size field, with count field, unspecified
//
// The type u8 is tested separately since it is likely to be handled
// idiomatically by the specific language generators.

struct Struct_Array_Field_ByteElement_ConstantSize_ {
    array: 8[4],
}
packet Struct_Array_Field_ByteElement_ConstantSize {
    s: Struct_Array_Field_ByteElement_ConstantSize_,
}

struct Struct_Array_Field_ByteElement_VariableSize_ {
    _size_(array) : 4,
    _reserved_: 4,
    array: 8[],
}
packet Struct_Array_Field_ByteElement_VariableSize {
    s: Struct_Array_Field_ByteElement_VariableSize_,
}

struct Struct_Array_Field_ByteElement_VariableCount_ {
    _count_(array) : 4,
    _reserved_: 4,
    array: 8[],
}
packet Struct_Array_Field_ByteElement_VariableCount {
    s: Struct_Array_Field_ByteElement_VariableCount_,
}

struct Struct_Array_Field_ByteElement_UnknownSize_ {
    array: 8[],
}
packet Struct_Array_Field_ByteElement_UnknownSize {
    s: Struct_Array_Field_ByteElement_UnknownSize_,
}

struct Struct_Array_Field_ScalarElement_ConstantSize_ {
    array: 16[4],
}
packet Struct_Array_Field_ScalarElement_ConstantSize {
    s: Struct_Array_Field_ScalarElement_ConstantSize_,
}

struct Struct_Array_Field_ScalarElement_VariableSize_ {
    _size_(array) : 4,
    _reserved_: 4,
    array: 16[],
}
packet Struct_Array_Field_ScalarElement_VariableSize {
    s: Struct_Array_Field_ScalarElement_VariableSize_,
}

struct Struct_Array_Field_ScalarElement_VariableCount_ {
    _count_(array) : 4,
    _reserved_: 4,
    array: 16[],
}
packet Struct_Array_Field_ScalarElement_VariableCount {
    s: Struct_Array_Field_ScalarElement_VariableCount_,
}

struct Struct_Array_Field_ScalarElement_UnknownSize_ {
    array: 16[],
}
packet Struct_Array_Field_ScalarElement_UnknownSize {
    s: Struct_Array_Field_ScalarElement_UnknownSize_,
}

struct Struct_Array_Field_EnumElement_ConstantSize_ {
    array: Enum16[4],
}
packet Struct_Array_Field_EnumElement_ConstantSize {
    s: Struct_Array_Field_EnumElement_ConstantSize_,
}

struct Struct_Array_Field_EnumElement_VariableSize_ {
    _size_(array) : 4,
    _reserved_: 4,
    array: Enum16[],
}
packet Struct_Array_Field_EnumElement_VariableSize {
    s: Struct_Array_Field_EnumElement_VariableSize_,
}

struct Struct_Array_Field_EnumElement_VariableCount_ {
    _count_(array) : 4,
    _reserved_: 4,
    array: Enum16[],
}
packet Struct_Array_Field_EnumElement_VariableCount {
    s: Struct_Array_Field_EnumElement_VariableCount_,
}

struct Struct_Array_Field_EnumElement_UnknownSize_ {
    array: Enum16[],
}
packet Struct_Array_Field_EnumElement_UnknownSize {
    s: Struct_Array_Field_EnumElement_UnknownSize_,
}

struct Struct_Array_Field_SizedElement_ConstantSize_ {
    array: SizedStruct[4],
}
packet Struct_Array_Field_SizedElement_ConstantSize {
    s: Struct_Array_Field_SizedElement_ConstantSize_,
}

struct Struct_Array_Field_SizedElement_VariableSize_ {
    _size_(array) : 4,
    _reserved_: 4,
    array: SizedStruct[],
}
packet Struct_Array_Field_SizedElement_VariableSize {
    s: Struct_Array_Field_SizedElement_VariableSize_,
}

struct Struct_Array_Field_SizedElement_VariableCount_ {
    _count_(array) : 4,
    _reserved_: 4,
    array: SizedStruct[],
}
packet Struct_Array_Field_SizedElement_VariableCount {
    s: Struct_Array_Field_SizedElement_VariableCount_,
}

struct Struct_Array_Field_SizedElement_UnknownSize_ {
    array: SizedStruct[],
}
packet Struct_Array_Field_SizedElement_UnknownSize {
    s: Struct_Array_Field_SizedElement_UnknownSize_,
}

struct Struct_Array_Field_UnsizedElement_ConstantSize_ {
    array: UnsizedStruct[4],
}
packet Struct_Array_Field_UnsizedElement_ConstantSize {
    s: Struct_Array_Field_UnsizedElement_ConstantSize_,
}

struct Struct_Array_Field_UnsizedElement_VariableSize_ {
    _size_(array) : 4,
    _reserved_: 4,
    array: UnsizedStruct[],
}
packet Struct_Array_Field_UnsizedElement_VariableSize {
    s: Struct_Array_Field_UnsizedElement_VariableSize_,
}

struct Struct_Array_Field_UnsizedElement_VariableCount_ {
    _count_(array) : 4,
    _reserved_: 4,
    array: UnsizedStruct[],
}
packet Struct_Array_Field_UnsizedElement_VariableCount {
    s: Struct_Array_Field_UnsizedElement_VariableCount_,
}

struct Struct_Array_Field_UnsizedElement_UnknownSize_ {
    array: UnsizedStruct[],
}
packet Struct_Array_Field_UnsizedElement_UnknownSize {
    s: Struct_Array_Field_UnsizedElement_UnknownSize_,
}

// The parser must support complex size modifiers on arrays whose size is
// specified by a size field.
struct Struct_Array_Field_UnsizedElement_SizeModifier_ {
    _size_(array) : 4,
    _reserved_: 4,
    array: UnsizedStruct[+2],
}
packet Struct_Array_Field_UnsizedElement_SizeModifier {
    s: Struct_Array_Field_UnsizedElement_SizeModifier_,
}

// The parser must be able to handle arrays with padded size.
struct Struct_Array_Field_SizedElement_VariableSize_Padded_ {
    _size_(array) : 4,
    _reserved_: 4,
    array: 16[],
    _padding_ [16],
}
packet Struct_Array_Field_SizedElement_VariableSize_Padded {
    s: Struct_Array_Field_SizedElement_VariableSize_Padded_,
}

// The parser must be able to handle arrays with padded size.
struct Struct_Array_Field_UnsizedElement_VariableCount_Padded_ {
    _count_(array) : 8,
    array: UnsizedStruct[],
    _padding_ [16],
}
packet Struct_Array_Field_UnsizedElement_VariableCount_Padded {
    s: Struct_Array_Field_UnsizedElement_VariableCount_Padded_,
}
